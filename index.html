<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>three.js - pointerlock controls</title>
    <link rel="stylesheet" href="styles.css" />
</head>
<body>

<div id="blocker">

    <div id="hurt" style="display: none"></div>
    <div id="instructions">
        <span style="font-size:40px">Click to play</span>
        <br />
        (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
    </div>

</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/1.1.29/howler.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.0.0/lodash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
<script src="OBJLoader.js"></script>
<script src="MTLLoader.js"></script>
<script src="OBJMTLLoader.js"></script>
<script src="PointerLockControls.js"></script>

<script>

var camera, scene, renderer;
var geometry, material, mesh;
var controls;

var objects = [];
var t = THREE;
var tried;

var raycaster;var ghosts = [];
var lastPos;
var target;
var ghostsHealth = [];

var blocker = document.getElementById( 'blocker' );
var instructions = document.getElementById( 'instructions' );

var lastHurt = Date.now();

var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

//Controls
var controlsEnabled = false;

var moveForward = false;
var moveBackward = false;
var moveLeft = false;
var moveRight = false;
var canJump = false;

//Animation
var prevTime = performance.now();
var velocity = new THREE.Vector3();

//Sounds
var hurtSounds = [
    'sounds/wav/hurt-01.wav',
    'sounds/wav/hurt-02.wav',
    'sounds/wav/hurt-03.wav'
];


function initialize() {
    var element;

    $('#hurt').hide();

    if ( havePointerLock ) {

        element = document.body;

        // Hook pointer lock state change events
        document.addEventListener('pointerlockchange', pointerlockchange, false );
        document.addEventListener('mozpointerlockchange', pointerlockchange, false );
        document.addEventListener('webkitpointerlockchange', pointerlockchange, false );

        document.addEventListener('pointerlockerror', pointerlockerror, false );
        document.addEventListener('mozpointerlockerror', pointerlockerror, false );
        document.addEventListener('webkitpointerlockerror', pointerlockerror, false );

        instructions.addEventListener( 'click', pointerlocksetup, false );

    } else {
        instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
    }

    function pointerlocksetup( event ) {

        instructions.style.display = 'none';

        // Ask the browser to lock the pointer
        element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

        if ( /Firefox/i.test( navigator.userAgent ) ) {

            document.addEventListener( 'fullscreenchange', fullscreenchange, false );
            document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

            element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

            element.requestFullscreen();

        } else {

            element.requestPointerLock();

        }

    }

    function fullscreenchange( event ) {

        if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

            document.removeEventListener( 'fullscreenchange', fullscreenchange );
            document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

            element.requestPointerLock();
        }

    }

    function pointerlockchange( event ) {

        if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

            controlsEnabled = true;
            controls.enabled = true;

            instructions.style.display = 'none';

        } else {

            controlsEnabled = false;
            controls.enabled = false;

            blocker.style.display = '-webkit-box';
            blocker.style.display = '-moz-box';
            blocker.style.display = 'box';

            instructions.style.display = '';

        }

    }

    function pointerlockerror( event ) {

        instructions.style.display = '';

    }
}

initialize();

setInterval(playRandomSound, 7000);

playRandomSound();

function playRandomSound() {
    var sounds = [
        'sounds/wav/scary_voice_01.wav',
        'sounds/wav/scary_voice_02.wav',
        'sounds/wav/scary_voice_03.wav',
        'sounds/wav/scary_voice_04.wav',
        'sounds/wav/scary_voice_05.wav',
        'sounds/wav/scary_voice_06.wav'
    ];

    var soundIndex = Math.floor(Math.random()*sounds.length);
    var sound = new Howl({
        urls: [sounds[soundIndex]],
        volume: 0.3
    }).play();
}

var playFootstep = _.throttle(function() {
    var sounds = [
        'sounds/wav/footstep_01.wav',
        'sounds/wav/footstep_02.wav',
    ];

    var soundIndex = Math.floor(Math.random()*sounds.length);
    var sound = new Howl({
        urls: [sounds[soundIndex]]
    }).play();
}, 250);

var loader = new t.OBJMTLLoader();
loader.load('./models/torch.obj', './materials/torch.mtl', function(mesh) {
    var loader = new t.TextureLoader();
    loader.load('./images/ghost.png', function(texture) {
        init(mesh, texture);
        setTimeout(animate, 100);
    }, function() {}, function(err) {
        ('error', err);
    });
});


function init(mesh, texture) {

    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );

    scene = new THREE.Scene();
    scene.fog = new THREE.Fog( 0x000000, 0, 750 );
    scene.add(camera);

    mesh.position.copy( camera.position ); // and reset spotlight position if camera moves
    mesh.rotateY(Math.PI / Math.PI - 1);
    mesh.position.set(8, 0, -10);

    var flashlight = new t.SpotLight(0xffffff,2,300);
    flashlight.position.copy(camera.position);
    flashlight.position.set(8, 0, -13);
    flashlight.castShadow = true;
    flashlight.shadowDarkness = 0.5;
    flashlight.shadowCameraVisible = true;

    target = new t.Object3D();

    target.position.copy(camera.position);
    target.position.z = -50;

    camera.add(target);

    flashlight.target = target;

    camera.add(flashlight);

    camera.add(mesh);

//    var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
//    light.position.set( 0.5, 1, 0.75 );
//    scene.add( light );

    controls = new THREE.PointerLockControls( camera );
    scene.add( controls.getObject() );

    var onKeyDown = function ( event ) {

        switch ( event.keyCode ) {

            case 38: // up
            case 87: // w
                moveForward = true;
                break;

            case 37: // left
            case 65: // a
                moveLeft = true; break;

            case 40: // down
            case 83: // s
                moveBackward = true;
                break;

            case 39: // right
            case 68: // d
                moveRight = true;
                break;

            case 32: // space
                if ( canJump === true ) velocity.y += 350;
                canJump = false;
                break;

        }

    };

    var onKeyUp = function ( event ) {

        switch( event.keyCode ) {

            case 38: // up
            case 87: // w
                moveForward = false;
                break;

            case 37: // left
            case 65: // a
                moveLeft = false;
                break;

            case 40: // down
            case 83: // s
                moveBackward = false;
                break;

            case 39: // right
            case 68: // d
                moveRight = false;
                break;

        }

    };

    document.addEventListener( 'keydown', onKeyDown, false );
    document.addEventListener( 'keyup', onKeyUp, false );

    raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );

    // floor
    geometry = new THREE.PlaneGeometry( 2000, 2000, 100, 100 );
    geometry.rotateX( - Math.PI / 2 );

    for ( var i = 0, l = geometry.vertices.length; i < l; i ++ ) {

        var vertex = geometry.vertices[ i ];
        vertex.x += Math.random() * 20 - 10;
        vertex.y += Math.random() * 2;
        vertex.z += Math.random() * 20 - 10;

    }

    for ( var i = 0, l = geometry.faces.length; i < l; i ++ ) {

        var face = geometry.faces[ i ];
        face.vertexColors[ 0 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
        face.vertexColors[ 1 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
        face.vertexColors[ 2 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );

    }

    material = new THREE.MeshPhongMaterial( { specular: 0x000000, shading: THREE.FlatShading, vertexColors: THREE.VertexColors } );
    mesh = new THREE.Mesh( geometry, material );
    mesh.position.set(0,0,40);
    scene.add( mesh );

    objects.push(mesh);

    // objects
    geometry = new THREE.BoxGeometry( 20, 20, 20 );

    for ( var i = 0, l = geometry.faces.length; i < l; i ++ ) {

        var face = geometry.faces[ i ];
        face.vertexColors[ 0 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
        face.vertexColors[ 1 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
        face.vertexColors[ 2 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );

    }

    for ( var i = 0; i < 500; i ++ ) {

        material = new THREE.MeshPhongMaterial( { specular: 0x000000, shading: THREE.FlatShading, vertexColors: THREE.VertexColors } );

        var mesh = new THREE.Mesh( geometry, material );
        mesh.position.x = Math.floor( Math.random() * 20 - 10 ) * 20;
        mesh.position.y = Math.floor( Math.random() * 20 ) * 20 + 40;
        mesh.position.z = Math.floor( Math.random() * 20 - 10 ) * 20;
        scene.add( mesh );

        material.color.setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );

        objects.push( mesh );

    }

    //ghosts

    for ( var i = 0, l = 10; i < l; i ++ ) {
        var ghost;

        geometry = new THREE.PlaneGeometry(20, 20, 2, 2 );
        material = new THREE.MeshPhongMaterial( { map: texture, shading: THREE.FlatShading, transparent: true} );

        ghost = new THREE.Mesh( geometry, material );
        ghost.material.side = THREE.DoubleSide;

        ghost.position.set(Math.floor(Math.random()*200) , 15, -(Math.floor(Math.random()*200) + 50));
        ghost.userData = {index: i};
        scene.add( ghost );

        objects.push(ghost);
        ghosts.push(ghost);

        ghost.lookAt(controls.getObject().position);
    }

    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor( 0x000000 );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    window.addEventListener( 'resize', onWindowResize, false );

    loaded = true;

}

function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}

function animate() {

    requestAnimationFrame( animate );

    if ( controlsEnabled && loaded) {
        raycaster.ray.origin.copy( controls.getObject().position );
        raycaster.ray.origin.y -= 10;

        var intersections = raycaster.intersectObjects( objects );

        var isOnObject = intersections.length > 0;

        var time = performance.now();
        var delta = ( time - prevTime ) / 1000;

        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

        velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

        if ( moveForward ) velocity.z -= 400.0 * delta;
        if ( moveBackward ) velocity.z += 400.0 * delta;

        if ( moveLeft ) velocity.x -= 400.0 * delta;
        if ( moveRight ) velocity.x += 400.0 * delta;

        if ( moveLeft || moveRight || moveForward || moveBackward ) {
          playFootstep();
        }

        if ( isOnObject === true ) {
            velocity.y = Math.max( 0, velocity.y );

            canJump = true;
        }

        controls.getObject().translateX( velocity.x * delta );
        controls.getObject().translateY( velocity.y * delta );
        controls.getObject().translateZ( velocity.z * delta );


        if ( controls.getObject().position.y < 10 ) {

            velocity.y = 0;
            controls.getObject().position.y = 10;

            canJump = true;

        }


        moveGhosts();
        checkLightCollision();
        prevTime = time;

        renderer.render( scene, camera );
    }

}

function moveGhosts() {
    var pos = controls.getObject().position;

    ghosts.map(function(ghost, i) {
        var x = ghost.position.x;
        var y = ghost.position.z;
        var xVal;
        var yVal;

        if (pos.x > x) {
            xVal = (1 / 4);
        } else {
            xVal = -(1 / 4)
        }

        if (pos.z > y) {
            yVal = (1 / 4);
        } else {
            yVal = - (1 / 4);
        }

        ghost.position.x = xVal + x;
        ghost.position.z = yVal + y;

        if (Date.now() % 10 === 0) {
            ghost.lookAt(pos);
        }
        var now = Date.now();

        if (lastHurt + 500 < now) {
            lastHurt = now;
            if (ghost.position.distanceTo(pos) < 40) {
                $('#hurt').fadeIn(75);
                $('#hurt').fadeOut(375);

                var hurtSoundIndex = Math.floor(Math.random()*hurtSounds.length);
                var hurtSound = new Howl({
                    urls: [hurtSounds[hurtSoundIndex]]
                }).play();
            }
        }
    });
}

function checkLightCollision() {
    if (!tried) {

    tried = true;
        return false;
    }
    var cont = controls.getObject();
    var dir = camera.getWorldDirection();
    var pos = cont.position;
    var ray = new THREE.Raycaster(pos, dir, pos, 80);

    var intersects = ray.intersectObjects(ghosts);

    if (intersects.length > 0) {

        intersects.map(function(intersect, i) {
            var ghost = intersect.object;
            var gho = ghost.position;
            var fromGhost = gho.distanceTo(pos);
            var tooClose = fromGhost < 10;

            if (!tooClose) {
                var health = ghostsHealth[ghost.userData.index];
                var now = Date.now();

                if (!health) {
                    health = {value: 11, lastChanged: now};
                    removeHealth(ghost, health);
                } else if (health.lastChanged + 500 < now) {
                    removeHealth(ghost, health)
                }

            }
        });
    }


}

function removeHealth(ghost, health) {
    var index = ghost.userData.index;
    var color = ghost.material.color;
    var percent;
    ghost = ghosts[index];

    health.value -= 1;
    health.lastChanged = Date.now();

    percent = health.value / 10;

    ghostsHealth[index] = health;

    ghost.material.color.setRGB(
        percent * color.r,
        percent * color.g,
        percent * color.b
    );

    if (health.value <= 0) {
        killGhost(ghost, index);
    }
}

function killGhost(ghost) {
    scene.remove(ghost);
}

</script>
</body>
</html>
